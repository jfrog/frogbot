name: Release Frogbot

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 3.0.1)'
        required: true
        type: string

# Required permissions
permissions:
  contents: write
  actions: read

jobs:
  release:
    name: Release Frogbot v3
    runs-on: ubuntu-latest

    steps:
      - name: Extract version from tag
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual trigger: use input version
            VERSION="${{ inputs.version }}"
            # Add 'v' prefix if not present
            if [[ ! "$VERSION" =~ ^v ]]; then
              TAG="v$VERSION"
            else
              TAG="$VERSION"
              VERSION="${VERSION#v}"
            fi
            
            # Validate it's a v3.x.x version
            if [[ ! "$TAG" =~ ^v3\.[0-9]+\.[0-9]+$ ]]; then
              echo "âŒ Error: Version must be v3.x.x format (e.g., v3.0.1)"
              echo "Got: $TAG"
              exit 1
            fi
          else
            # Release trigger: use release tag
            TAG="${{ github.event.release.tag_name }}"
            VERSION="${TAG#v}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "âœ… Release version: $VERSION"
          echo "âœ… Release tag: $TAG"

      - name: Check if tag already exists
        if: github.event_name == 'workflow_dispatch'
        uses: actions/github-script@v7
        with:
          script: |
            const tag = '${{ steps.version.outputs.tag }}';
            
            try {
              // Check if tag exists
              await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${tag}`
              });
              
              // Tag exists - fail the workflow
              core.setFailed(`âŒ Tag ${tag} already exists! Please use a different version.`);
            } catch (error) {
              if (error.status === 404) {
                // Tag doesn't exist - good to proceed
                console.log(`âœ… Tag ${tag} does not exist, proceeding with release`);
              } else {
                // Some other error
                throw error;
              }
            }

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && github.ref || github.event.release.tag_name }}
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Download JFrog CLI
        run: |
          curl -fL https://install-cli.jfrog.io | sh
          # The install script already moves jf to /usr/local/bin/

      - name: Configure JFrog CLI
        env:
          JF_URL: ${{ secrets.JF_URL }}
          JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
        run: |
          jf c rm --quiet || true
          jf c add internal --url="$JF_URL" --access-token="$JF_ACCESS_TOKEN"
          jf goc --repo-resolve ecosys-go-virtual

      - name: Generate mocks
        run: go generate ./...

      - name: Run JFrog Audit (non-blocking)
        env:
          JF_URL: ${{ secrets.JF_URL }}
          JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
        run: jf audit --fail=true

      - name: Set up Node.js for ActionÃ˜
        uses: actions/setup-node@v4
        with:
          node-version: '16'
          cache: 'npm'
          cache-dependency-path: action/package-lock.json

      - name: Build GitHub Action
        working-directory: action
        run: |
          npm ci --ignore-scripts
          npm run compile
          npm run format-check
          npm test

      - name: Commit and update tag with compiled action
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add action/lib/
          
          # Check if there are changes
          CHANGES=false
          if ! git diff --staged --quiet; then
            echo "Action files changed, committing..."
            git commit -m "Build action for ${{ steps.version.outputs.tag }}"
            CHANGES=true
          else
            echo "No changes to action files"
          fi
          
          # For manual triggers, always create/update the tag
          # For release triggers, update the tag only if there were changes
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] || [ "$CHANGES" = "true" ]; then
            echo "Creating/updating tag ${{ steps.version.outputs.tag }}..."
            git tag -f ${{ steps.version.outputs.tag }}
            git push origin ${{ steps.version.outputs.tag }} --force
            echo "Tag ${{ steps.version.outputs.tag }} created/updated"
          fi

      - name: Update GitHub Action major version tag (v3)
        run: |
          # Update v3 tag to point to the latest v3.x.x release
          git tag -f v3
          git push origin v3 --force
          echo "Updated v3 tag to ${{ steps.version.outputs.tag }}"

      - name: Build and upload binaries
        env:
          VERSION: ${{ steps.version.outputs.tag }}
          JFROG_CLI_BUILD_NAME: ecosystem-frogbot-release
          JFROG_CLI_BUILD_NUMBER: ${{ github.run_number }}
          JFROG_CLI_BUILD_PROJECT: ecosys
        run: |
          env -i PATH=$PATH HOME=$HOME \
            JFROG_CLI_BUILD_NAME=$JFROG_CLI_BUILD_NAME \
            JFROG_CLI_BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER \
            JFROG_CLI_BUILD_PROJECT=$JFROG_CLI_BUILD_PROJECT \
            CI=true \
            release/buildAndUpload.sh "${{ steps.version.outputs.version }}"

      - name: Publish build info
        env:
          JFROG_CLI_BUILD_NAME: ecosystem-frogbot-release
          JFROG_CLI_BUILD_NUMBER: ${{ github.run_number }}
          JFROG_CLI_BUILD_PROJECT: ecosys
        run: |
          jf rt bag
          jf rt bce
          jf rt bp

      - name: Create and distribute release bundle
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          jf ds rbc ecosystem-frogbot $VERSION \
            --spec="release/specs/frogbot-rbc-spec.json" \
            --spec-vars="VERSION=$VERSION" \
            --sign
          jf ds rbd ecosystem-frogbot $VERSION \
            --site="releases.jfrog.io" \
            --sync

      - name: Create GitHub Release
        if: github.event_name == 'workflow_dispatch'
        uses: actions/github-script@v7
        with:
          script: |
            const tag = '${{ steps.version.outputs.tag }}';
            
            console.log(`Creating release for tag ${tag}`);
            
            // The tag was already created and pushed in the previous step
            // Now create the release with auto-generated notes
            // Note: make_latest is set to false so this doesn't become the "Latest" release
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tag,
              name: `Release ${tag}`,
              generate_release_notes: true,
              draft: false,
              prerelease: false,
              make_latest: false
            });
            
            console.log(`âœ… Created release ${release.data.id} for ${tag}`);
            console.log(`ðŸ“¦ Release URL: ${release.data.html_url}`);
            console.log(`â„¹ï¸  This release is NOT marked as "Latest"`);

      - name: Cleanup JFrog config
        if: always()
        run: jf c rm --quiet || true

      # On failure: delete release and tag
      - name: Delete release on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const tag = '${{ steps.version.outputs.tag }}';
            
            console.log(`Workflow failed, cleaning up tag ${tag}`);
            
            try {
              // Try to find and delete the release
              const releases = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              
              const release = releases.data.find(r => r.tag_name === tag);
              if (release) {
                console.log(`Deleting release ${release.id}`);
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release.id
                });
                console.log('Release deleted');
              } else {
                console.log('No release found to delete');
              }
              
              // Delete the tag
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${tag}`
                });
                console.log('Tag deleted');
              } catch (error) {
                console.log(`Tag deletion failed or tag doesn't exist: ${error.message}`);
              }
            } catch (error) {
              console.error(`Cleanup failed: ${error.message}`);
              // Don't fail the workflow if cleanup fails
            }

